From 354db3b141a352b08b6e59f6df4cccef13989d0e Mon Sep 17 00:00:00 2001
From: Sven Strickroth <email@cs-ware.de>
Date: Sun, 1 Feb 2015 13:39:31 +0100
Subject: [PATCH 5/7] Make CRLF filter behave like vanilla git for adding files
 in combination with attributes

Based on lots of manual testing (even with "malformed" files and binary) with vanilla git executable...

Signed-off-by: Sven Strickroth <email@cs-ware.de>
---
 CHANGELOG.md        |    5 +
 src/crlf.c          |   58 +--
 tests/filter/crlf.h |   18 +
 tests/index/crlf.c  | 1200 ++++++++++++++++++++++++++++++++++++++++++++++++++-
 4 files changed, 1248 insertions(+), 33 deletions(-)

diff --git a/CHANGELOG.md b/CHANGELOG.md
index d210632..b22b497 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -15,6 +15,11 @@ v0.22 + 1
   * files containig CRLF in combination with core.autocrlf=input were accepted
   * adding files containing CR and CRLF but not the same number failed
 
+* LF -> CRLF filter now handles files on adding to index the way vanilla git does
+  * skip files marked as "binary" (-crlf)
+  * especially files containing single CR chars are added as is now
+  * honor "text" attribute for forcing a file being interpreted as text
+
 * Rename and copy detection is enabled for small files.
 
 * Checkout can now handle an initial checkout of a repository, making
diff --git a/src/crlf.c b/src/crlf.c
index 2de107c..2507d2b 100644
--- a/src/crlf.c
+++ b/src/crlf.c
@@ -124,18 +124,21 @@ static int crlf_apply_to_odb(
 	const git_buf *from,
 	const git_filter_source *src)
 {
+	git_buf_text_stats stats;
+	bool is_binary;
+
 	/* Empty file? Nothing to do */
 	if (!git_buf_len(from))
 		return 0;
 
+	is_binary = git_buf_text_gather_stats(&stats, from, false);
+
 	/* Heuristics to see if we can skip the conversion.
 	 * Straight from Core Git.
 	 */
 	if (ca->crlf_action == GIT_CRLF_AUTO || ca->crlf_action == GIT_CRLF_GUESS) {
-		git_buf_text_stats stats;
-
-		/* Check heuristics for binary vs text - returns true if binary */
-		if (git_buf_text_gather_stats(&stats, from, false))
+		/* Check heuristics for binary vs text */
+		if (is_binary)
 			return GIT_PASSTHROUGH;
 
 		/*
@@ -146,16 +149,26 @@ static int crlf_apply_to_odb(
 		if (stats.cr != stats.crlf)
 			return GIT_PASSTHROUGH;
 
-		/* If there are no CR characters to filter out and CrLf is not set to "true", then just pass */
-		if (!stats.cr && ca->auto_crlf != GIT_AUTO_CRLF_TRUE)
-			return GIT_PASSTHROUGH;
+		if (ca->crlf_action == GIT_CRLF_GUESS) {
+			/*
+			 * If the file in the index has any CR in it, do not convert.
+			 * This is the new safer autocrlf handling.
+			 */
+			if (has_cr_in_index(src))
+				return GIT_PASSTHROUGH;
+		}
+	}
 
-		/* If safecrlf is enabled, sanity-check the result. */
-		if (stats.lf != stats.crlf) {
+	/* If safecrlf is enabled, sanity-check the result. */
+	if (ca->crlf_action == GIT_CRLF_INPUT ||
+		(ca->auto_crlf == GIT_AUTO_CRLF_INPUT &&
+		(ca->crlf_action == GIT_CRLF_GUESS || ca->crlf_action == GIT_CRLF_AUTO ||
+		(ca->crlf_action == GIT_CRLF_TEXT && ca->eol==GIT_EOL_UNSET)))) {
+		if (stats.crlf) {
 			switch (ca->safe_crlf) {
 			case GIT_SAFE_CRLF_FAIL:
 				giterr_set(
-					GITERR_FILTER, "LF would be replaced by CRLF in '%s'",
+					GITERR_FILTER, "CRLF would be replaced by LF in '%s'",
 					git_filter_source_path(src));
 				return -1;
 			case GIT_SAFE_CRLF_WARN:
@@ -164,11 +177,16 @@ static int crlf_apply_to_odb(
 			default:
 				break;
 			}
-		} else if (stats.crlf && ca->auto_crlf == GIT_AUTO_CRLF_INPUT) {
+		}
+	} else if (ca->crlf_action == GIT_CRLF_CRLF ||
+				(ca->auto_crlf == GIT_AUTO_CRLF_TRUE &&
+				(ca->crlf_action == GIT_CRLF_GUESS || ca->crlf_action == GIT_CRLF_AUTO ||
+				(ca->crlf_action == GIT_CRLF_TEXT && ca->eol == GIT_EOL_UNSET)))) {
+		if (stats.lf != stats.crlf) {
 			switch (ca->safe_crlf) {
 			case GIT_SAFE_CRLF_FAIL:
 				giterr_set(
-					GITERR_FILTER, "CRLF would be replaced by LF in '%s'",
+					GITERR_FILTER, "LF would be replaced by CRLF in '%s'",
 					git_filter_source_path(src));
 				return -1;
 			case GIT_SAFE_CRLF_WARN:
@@ -178,20 +196,12 @@ static int crlf_apply_to_odb(
 				break;
 			}
 		}
-
-		if (ca->crlf_action == GIT_CRLF_GUESS) {
-			/*
-			 * If the file in the index has any CR in it, do not convert.
-			 * This is the new safer autocrlf handling.
-			 */
-			if (has_cr_in_index(src))
-				return GIT_PASSTHROUGH;
-		}
-
-		if (!stats.cr)
-			return GIT_PASSTHROUGH;
 	}
 
+	/* If there are no CR characters to filter out, then just pass */
+	if (!stats.cr)
+		return GIT_PASSTHROUGH;
+
 	/* Actually drop the carriage returns */
 	return git_buf_text_crlf_to_lf(to, from);
 }
diff --git a/tests/filter/crlf.h b/tests/filter/crlf.h
index 786edfc..bb13162 100644
--- a/tests/filter/crlf.h
+++ b/tests/filter/crlf.h
@@ -11,16 +11,34 @@
 #define ALL_LF_TEXT_RAW			"lf\nlf\nlf\nlf\nlf\n"
 #define MORE_CRLF_TEXT_RAW		"crlf\r\ncrlf\r\nlf\ncrlf\r\ncrlf\r\n"
 #define MORE_LF_TEXT_RAW		"lf\nlf\ncrlf\r\nlf\nlf\n"
+#define MIXED_LF_CR_RAW			"one\ntwo\rthree\nfour\r"
+#define MIXED_LF_CR_CRLF_RAW	"one\ntwo\rthree\r\nfour\r"
+#define BINARY_ALL_CRLF_TEXT_RAW	"\01one\r\ntwo\r\nthree\r\nfour\r\n"
+#define BINARY_ALL_LF_TEXT_RAW		"\01one\ntwo\nthree\nfour\n"
+#define BINARY_MIXED_LF_CR_RAW		"\01" MIXED_LF_CR_RAW
+#define BINARY_MIXED_LF_CR_CRLF_RAW	"\01" MIXED_LF_CR_CRLF_RAW
 
 #define ALL_CRLF_TEXT_AS_CRLF	ALL_CRLF_TEXT_RAW
 #define ALL_LF_TEXT_AS_CRLF		"lf\r\nlf\r\nlf\r\nlf\r\nlf\r\n"
 #define MORE_CRLF_TEXT_AS_CRLF	"crlf\r\ncrlf\r\nlf\r\ncrlf\r\ncrlf\r\n"
 #define MORE_LF_TEXT_AS_CRLF	"lf\r\nlf\r\ncrlf\r\nlf\r\nlf\r\n"
+#define MIXED_LF_CR_AS_CRLF		"one\r\ntwo\rthree\r\nfour\r"
+#define MIXED_LF_CR_CRLF_AS_CRLF	MIXED_LF_CR_AS_CRLF
+#define BINARY_ALL_CRLF_TEXT_AS_CRLF	BINARY_ALL_CRLF_TEXT_RAW
+#define BINARY_ALL_LF_TEXT_AS_CRLF		BINARY_ALL_CRLF_TEXT_AS_CRLF
+#define BINARY_MIXED_LF_CR_AS_CRLF		"\01" MIXED_LF_CR_AS_CRLF
+#define BINARY_MIXED_LF_CR_CRLF_AS_CRLF	BINARY_MIXED_LF_CR_AS_CRLF
 
 #define ALL_CRLF_TEXT_AS_LF		"crlf\ncrlf\ncrlf\ncrlf\n"
 #define ALL_LF_TEXT_AS_LF		ALL_LF_TEXT_RAW
 #define MORE_CRLF_TEXT_AS_LF	"crlf\ncrlf\nlf\ncrlf\ncrlf\n"
 #define MORE_LF_TEXT_AS_LF		"lf\nlf\ncrlf\nlf\nlf\n"
+#define MIXED_LF_CR_AS_LF		MIXED_LF_CR_RAW
+#define MIXED_LF_CR_CRLF_AS_LF	MIXED_LF_CR_CRLF_RAW
+#define BINARY_ALL_CRLF_TEXT_AS_LF		BINARY_ALL_CRLF_TEXT_RAW
+#define BINARY_ALL_LF_TEXT_AS_LF		BINARY_ALL_LF_TEXT_RAW
+#define BINARY_MIXED_LF_CR_AS_LF		BINARY_MIXED_LF_CR_RAW
+#define BINARY_MIXED_LF_CR_CRLF_AS_LF	BINARY_MIXED_LF_CR_CRLF_RAW
 
 #define FEW_UTF8_CRLF_RAW		"\xe2\x9a\xbdThe rest is ASCII01.\r\nThe rest is ASCII02.\r\nThe rest is ASCII03.\r\nThe rest is ASCII04.\r\nThe rest is ASCII05.\r\nThe rest is ASCII06.\r\nThe rest is ASCII07.\r\nThe rest is ASCII08.\r\nThe rest is ASCII09.\r\nThe rest is ASCII10.\r\nThe rest is ASCII11.\r\nThe rest is ASCII12.\r\nThe rest is ASCII13.\r\nThe rest is ASCII14.\r\nThe rest is ASCII15.\r\nThe rest is ASCII16.\r\nThe rest is ASCII17.\r\nThe rest is ASCII18.\r\nThe rest is ASCII19.\r\nThe rest is ASCII20.\r\nThe rest is ASCII21.\r\nThe rest is ASCII22.\r\n"
 #define FEW_UTF8_LF_RAW			"\xe2\x9a\xbdThe rest is ASCII01.\nThe rest is ASCII02.\nThe rest is ASCII03.\nThe rest is ASCII04.\nThe rest is ASCII05.\nThe rest is ASCII06.\nThe rest is ASCII07.\nThe rest is ASCII08.\nThe rest is ASCII09.\nThe rest is ASCII10.\nThe rest is ASCII11.\nThe rest is ASCII12.\nThe rest is ASCII13.\nThe rest is ASCII14.\nThe rest is ASCII15.\nThe rest is ASCII16.\nThe rest is ASCII17.\nThe rest is ASCII18.\nThe rest is ASCII19.\nThe rest is ASCII20.\nThe rest is ASCII21.\nThe rest is ASCII22.\n"
diff --git a/tests/index/crlf.c b/tests/index/crlf.c
index 38e7916..c9d2d84 100644
--- a/tests/index/crlf.c
+++ b/tests/index/crlf.c
@@ -7,9 +7,34 @@
 
 #define FILE_CONTENTS_LF "one\ntwo\nthree\nfour\n"
 #define FILE_CONTENTS_CRLF "one\r\ntwo\r\nthree\r\nfour\r\n"
+#define FILE_CONTENTS_MORE_CRLF MORE_CRLF_TEXT_RAW
+#define FILE_CONTENTS_MORE_LF MORE_LF_TEXT_RAW
+#define FILE_CONTENTS_LF_CR MIXED_LF_CR_RAW
+#define FILE_CONTENTS_LF_CR_CRLF MIXED_LF_CR_CRLF_RAW
+#define FILE_CONTENTS_BINARY_LF "\01" FILE_CONTENTS_LF
+#define FILE_CONTENTS_BINARY_CRLF "\01" FILE_CONTENTS_CRLF
+#define FILE_CONTENTS_BINARY_LF_CR "\01" FILE_CONTENTS_LF_CR
+#define FILE_CONTENTS_BINARY_LF_CR_CRLF "\01" FILE_CONTENTS_LF_CR_CRLF
 
 #define FILE_OID_LF "f384549cbeb481e437091320de6d1f2e15e11b4a"
 #define FILE_OID_CRLF "7fbf4d847b191141d80f30c8ab03d2ad4cd543a9"
+#define FILE_OID_MORE_CRLF "0ff5a53f19bfd2b5eea1ba550295c47515678987"
+#define FILE_OID_MORE_LF "04de00b358f13389948756732158eaaaefa1448c"
+#define FILE_OID_LF_CR "d11e7ef63ba7db1db3b1b99cdbafc57a8549f8a4"
+#define FILE_OID_LF_CR_CRLF "417786fc35b3c71aa546e3f95eb5da3c8dad8c41"
+#define FILE_OID_BINARY_LF "af6fcf6da196f615d7cda269b55b5c4ecfb4a5b3"
+#define FILE_OID_BINARY_CRLF "85340755cfe5e28c2835781978bb1cece91b3d0f"
+#define FILE_OID_BINARY_LF_CR "203555c5676d75cd80d69b50beb1f4b588c59ceb"
+#define FILE_OID_BINARY_LF_CR_CRLF "aaf083a9cb53dac3669dcfa0e48921580d629ec7"
+
+#define CHECK_CRLF_TO_LF_ERROR cl_assert(giterr_last() != NULL && \
+							   giterr_last()->klass == GITERR_FILTER && \
+							   strstr(giterr_last()->message, "CRLF would be replaced by LF in") != NULL); \
+							   giterr_clear();
+#define CHECK_LF_TO_CRLF_ERROR cl_assert(giterr_last() != NULL && \
+							   giterr_last()->klass == GITERR_FILTER && \
+							   strstr(giterr_last()->message, "LF would be replaced by CRLF in") != NULL); \
+							   giterr_clear();
 
 static git_repository *g_repo;
 static git_index *g_index;
@@ -42,6 +67,54 @@ void test_index_crlf__autocrlf_false_no_attrs(void)
 	cl_git_pass(git_oid_fromstr(&oid,
 		(GIT_EOL_NATIVE == GIT_EOL_CRLF) ? FILE_OID_CRLF : FILE_OID_LF));
 	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("./crlf/newfile.txt", FILE_CONTENTS_MORE_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.txt"));
+	entry = git_index_get_bypath(g_index, "newfile.txt", 0);
+	cl_git_pass(git_oid_fromstr(&oid, FILE_OID_MORE_CRLF));
+	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("./crlf/newfile.txt", FILE_CONTENTS_MORE_LF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.txt"));
+	entry = git_index_get_bypath(g_index, "newfile.txt", 0);
+	cl_git_pass(git_oid_fromstr(&oid, FILE_OID_MORE_LF));
+	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("./crlf/newfile1.txt", FILE_CONTENTS_LF_CR);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile1.txt"));
+	entry = git_index_get_bypath(g_index, "newfile1.txt", 0);
+	cl_git_pass(git_oid_fromstr(&oid, FILE_OID_LF_CR));
+	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("./crlf/newfile2.txt", FILE_CONTENTS_LF_CR_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile2.txt"));
+	entry = git_index_get_bypath(g_index, "newfile2.txt", 0);
+	cl_git_pass(git_oid_fromstr(&oid, FILE_OID_LF_CR_CRLF));
+	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("./crlf/newfile3.txt", FILE_CONTENTS_BINARY_LF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile3.txt"));
+	entry = git_index_get_bypath(g_index, "newfile3.txt", 0);
+	cl_git_pass(git_oid_fromstr(&oid, FILE_OID_BINARY_LF));
+	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("./crlf/newfile4.txt", FILE_CONTENTS_BINARY_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile4.txt"));
+	entry = git_index_get_bypath(g_index, "newfile4.txt", 0);
+	cl_git_pass(git_oid_fromstr(&oid, FILE_OID_BINARY_CRLF));
+	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("./crlf/newfile5.txt", FILE_CONTENTS_BINARY_LF_CR);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile5.txt"));
+	entry = git_index_get_bypath(g_index, "newfile5.txt", 0);
+	cl_git_pass(git_oid_fromstr(&oid, FILE_OID_BINARY_LF_CR));
+	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("./crlf/newfile6.txt", FILE_CONTENTS_BINARY_LF_CR_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile6.txt"));
+	entry = git_index_get_bypath(g_index, "newfile6.txt", 0);
+	cl_git_pass(git_oid_fromstr(&oid, FILE_OID_BINARY_LF_CR_CRLF));
+	cl_assert_equal_oid(&oid, &entry->id);
 }
 
 void test_index_crlf__autocrlf_true_no_attrs(void)
@@ -59,6 +132,63 @@ void test_index_crlf__autocrlf_true_no_attrs(void)
 
 	cl_git_pass(git_oid_fromstr(&oid, FILE_OID_LF));
 	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("./crlf/newfile2.txt",
+		(GIT_EOL_NATIVE == GIT_EOL_CRLF) ? FILE_CONTENTS_LF : FILE_CONTENTS_CRLF);
+
+	cl_git_pass(git_index_add_bypath(g_index, "newfile2.txt"));
+	entry = git_index_get_bypath(g_index, "newfile2.txt", 0);
+
+	cl_git_pass(git_oid_fromstr(&oid, FILE_OID_LF));
+	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("./crlf/newfile.txt", FILE_CONTENTS_MORE_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.txt"));
+	entry = git_index_get_bypath(g_index, "newfile.txt", 0);
+	cl_git_pass(git_oid_fromstr(&oid, "37bb7fa3debea1cbb65576733a457347ea1bb74d"));
+	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("./crlf/newfile.txt", FILE_CONTENTS_MORE_LF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.txt"));
+	entry = git_index_get_bypath(g_index, "newfile.txt", 0);
+	cl_git_pass(git_oid_fromstr(&oid, "2cda6f203b2f56d5c416b94b28670ec3eafb1398"));
+	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("./crlf/newfile3.txt", FILE_CONTENTS_LF_CR);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile3.txt"));
+	entry = git_index_get_bypath(g_index, "newfile3.txt", 0);
+	cl_git_pass(git_oid_fromstr(&oid, FILE_OID_LF_CR));
+	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("./crlf/newfile3.txt", FILE_CONTENTS_LF_CR_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile3.txt"));
+	entry = git_index_get_bypath(g_index, "newfile3.txt", 0);
+	cl_git_pass(git_oid_fromstr(&oid, FILE_OID_LF_CR_CRLF));
+	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("./crlf/newfile4.txt", FILE_CONTENTS_BINARY_LF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile4.txt"));
+	entry = git_index_get_bypath(g_index, "newfile4.txt", 0);
+	cl_git_pass(git_oid_fromstr(&oid, FILE_OID_BINARY_LF));
+	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("./crlf/newfile5.txt", FILE_CONTENTS_BINARY_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile5.txt"));
+	entry = git_index_get_bypath(g_index, "newfile5.txt", 0);
+	cl_git_pass(git_oid_fromstr(&oid, FILE_OID_BINARY_CRLF));
+	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("./crlf/newfile6.txt", FILE_CONTENTS_BINARY_LF_CR);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile6.txt"));
+	entry = git_index_get_bypath(g_index, "newfile6.txt", 0);
+	cl_git_pass(git_oid_fromstr(&oid, FILE_OID_BINARY_LF_CR));
+	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("./crlf/newfile7.txt", FILE_CONTENTS_BINARY_LF_CR_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile7.txt"));
+	entry = git_index_get_bypath(g_index, "newfile7.txt", 0);
+	cl_git_pass(git_oid_fromstr(&oid, FILE_OID_BINARY_LF_CR_CRLF));
+	cl_assert_equal_oid(&oid, &entry->id);
 }
 
 void test_index_crlf__autocrlf_input_no_attrs(void)
@@ -76,6 +206,42 @@ void test_index_crlf__autocrlf_input_no_attrs(void)
 
 	cl_git_pass(git_oid_fromstr(&oid, FILE_OID_LF));
 	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("./crlf/newfile.txt", FILE_CONTENTS_MORE_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.txt"));
+	entry = git_index_get_bypath(g_index, "newfile.txt", 0);
+	cl_git_pass(git_oid_fromstr(&oid, "37bb7fa3debea1cbb65576733a457347ea1bb74d"));
+	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("./crlf/newfile.txt", FILE_CONTENTS_MORE_LF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.txt"));
+	entry = git_index_get_bypath(g_index, "newfile.txt", 0);
+	cl_git_pass(git_oid_fromstr(&oid, "2cda6f203b2f56d5c416b94b28670ec3eafb1398"));
+	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("./crlf/newfile4.txt", FILE_CONTENTS_BINARY_LF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile4.txt"));
+	entry = git_index_get_bypath(g_index, "newfile4.txt", 0);
+	cl_git_pass(git_oid_fromstr(&oid, FILE_OID_BINARY_LF));
+	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("./crlf/newfile5.txt", FILE_CONTENTS_BINARY_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile5.txt"));
+	entry = git_index_get_bypath(g_index, "newfile5.txt", 0);
+	cl_git_pass(git_oid_fromstr(&oid, FILE_OID_BINARY_CRLF));
+	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("./crlf/newfile6.txt", FILE_CONTENTS_BINARY_LF_CR);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile6.txt"));
+	entry = git_index_get_bypath(g_index, "newfile6.txt", 0);
+	cl_git_pass(git_oid_fromstr(&oid, FILE_OID_BINARY_LF_CR));
+	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("./crlf/newfile7.txt", FILE_CONTENTS_BINARY_LF_CR_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile7.txt"));
+	entry = git_index_get_bypath(g_index, "newfile7.txt", 0);
+	cl_git_pass(git_oid_fromstr(&oid, FILE_OID_BINARY_LF_CR_CRLF));
+	cl_assert_equal_oid(&oid, &entry->id);
 }
 
 void test_index_crlf__autocrlf_false_text_auto_attr(void)
@@ -95,6 +261,42 @@ void test_index_crlf__autocrlf_false_text_auto_attr(void)
 
 	cl_git_pass(git_oid_fromstr(&oid, FILE_OID_LF));
 	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("./crlf/newfile.txt", FILE_CONTENTS_MORE_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.txt"));
+	entry = git_index_get_bypath(g_index, "newfile.txt", 0);
+	cl_git_pass(git_oid_fromstr(&oid, "37bb7fa3debea1cbb65576733a457347ea1bb74d"));
+	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("./crlf/newfile.txt", FILE_CONTENTS_MORE_LF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.txt"));
+	entry = git_index_get_bypath(g_index, "newfile.txt", 0);
+	cl_git_pass(git_oid_fromstr(&oid, "2cda6f203b2f56d5c416b94b28670ec3eafb1398"));
+	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("./crlf/newfile3.txt", FILE_CONTENTS_BINARY_LF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile3.txt"));
+	entry = git_index_get_bypath(g_index, "newfile3.txt", 0);
+	cl_git_pass(git_oid_fromstr(&oid, FILE_OID_BINARY_LF));
+	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("./crlf/newfile4.txt", FILE_CONTENTS_BINARY_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile4.txt"));
+	entry = git_index_get_bypath(g_index, "newfile4.txt", 0);
+	cl_git_pass(git_oid_fromstr(&oid, FILE_OID_BINARY_CRLF));
+	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("./crlf/newfile5.txt", FILE_CONTENTS_BINARY_LF_CR);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile5.txt"));
+	entry = git_index_get_bypath(g_index, "newfile5.txt", 0);
+	cl_git_pass(git_oid_fromstr(&oid, FILE_OID_BINARY_LF_CR));
+	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("./crlf/newfile6.txt", FILE_CONTENTS_BINARY_LF_CR_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile6.txt"));
+	entry = git_index_get_bypath(g_index, "newfile6.txt", 0);
+	cl_git_pass(git_oid_fromstr(&oid, FILE_OID_BINARY_LF_CR_CRLF));
+	cl_assert_equal_oid(&oid, &entry->id);
 }
 
 void test_index_crlf__autocrlf_true_text_auto_attr(void)
@@ -104,7 +306,7 @@ void test_index_crlf__autocrlf_true_text_auto_attr(void)
 
 	cl_git_mkfile("./crlf/.gitattributes", "* text=auto\n");
 
-	cl_repo_set_bool(g_repo, "core.autocrlf", false);
+	cl_repo_set_bool(g_repo, "core.autocrlf", true);
 
 	cl_git_mkfile("./crlf/newfile.txt",
 		(GIT_EOL_NATIVE == GIT_EOL_CRLF) ? FILE_CONTENTS_CRLF : FILE_CONTENTS_LF);
@@ -114,6 +316,42 @@ void test_index_crlf__autocrlf_true_text_auto_attr(void)
 
 	cl_git_pass(git_oid_fromstr(&oid, FILE_OID_LF));
 	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("./crlf/newfile.txt", FILE_CONTENTS_MORE_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.txt"));
+	entry = git_index_get_bypath(g_index, "newfile.txt", 0);
+	cl_git_pass(git_oid_fromstr(&oid, "37bb7fa3debea1cbb65576733a457347ea1bb74d"));
+	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("./crlf/newfile.txt", FILE_CONTENTS_MORE_LF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.txt"));
+	entry = git_index_get_bypath(g_index, "newfile.txt", 0);
+	cl_git_pass(git_oid_fromstr(&oid, "2cda6f203b2f56d5c416b94b28670ec3eafb1398"));
+	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("./crlf/newfile3.txt", FILE_CONTENTS_BINARY_LF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile3.txt"));
+	entry = git_index_get_bypath(g_index, "newfile3.txt", 0);
+	cl_git_pass(git_oid_fromstr(&oid, FILE_OID_BINARY_LF));
+	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("./crlf/newfile4.txt", FILE_CONTENTS_BINARY_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile4.txt"));
+	entry = git_index_get_bypath(g_index, "newfile4.txt", 0);
+	cl_git_pass(git_oid_fromstr(&oid, FILE_OID_BINARY_CRLF));
+	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("./crlf/newfile5.txt", FILE_CONTENTS_BINARY_LF_CR);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile5.txt"));
+	entry = git_index_get_bypath(g_index, "newfile5.txt", 0);
+	cl_git_pass(git_oid_fromstr(&oid, FILE_OID_BINARY_LF_CR));
+	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("./crlf/newfile6.txt", FILE_CONTENTS_BINARY_LF_CR_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile6.txt"));
+	entry = git_index_get_bypath(g_index, "newfile6.txt", 0);
+	cl_git_pass(git_oid_fromstr(&oid, FILE_OID_BINARY_LF_CR_CRLF));
+	cl_assert_equal_oid(&oid, &entry->id);
 }
 
 void test_index_crlf__autocrlf_input_text_auto_attr(void)
@@ -133,6 +371,59 @@ void test_index_crlf__autocrlf_input_text_auto_attr(void)
 
 	cl_git_pass(git_oid_fromstr(&oid, FILE_OID_LF));
 	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("./crlf/newfile2.txt",
+		(GIT_EOL_NATIVE == GIT_EOL_CRLF) ? FILE_CONTENTS_LF : FILE_CONTENTS_CRLF);
+
+	cl_git_pass(git_index_add_bypath(g_index, "newfile2.txt"));
+	entry = git_index_get_bypath(g_index, "newfile2.txt", 0);
+
+	cl_git_pass(git_oid_fromstr(&oid, FILE_OID_LF));
+	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("./crlf/newfile3.txt", FILE_CONTENTS_LF_CR_CRLF);
+
+	cl_git_pass(git_index_add_bypath(g_index, "newfile3.txt"));
+	entry = git_index_get_bypath(g_index, "newfile3.txt", 0);
+
+	cl_git_pass(git_oid_fromstr(&oid, FILE_OID_LF_CR_CRLF));
+	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("./crlf/newfile.txt", FILE_CONTENTS_MORE_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.txt"));
+	entry = git_index_get_bypath(g_index, "newfile.txt", 0);
+	cl_git_pass(git_oid_fromstr(&oid, "37bb7fa3debea1cbb65576733a457347ea1bb74d"));
+	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("./crlf/newfile.txt", FILE_CONTENTS_MORE_LF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.txt"));
+	entry = git_index_get_bypath(g_index, "newfile.txt", 0);
+	cl_git_pass(git_oid_fromstr(&oid, "2cda6f203b2f56d5c416b94b28670ec3eafb1398"));
+	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("./crlf/newfile3.txt", FILE_CONTENTS_BINARY_LF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile3.txt"));
+	entry = git_index_get_bypath(g_index, "newfile3.txt", 0);
+	cl_git_pass(git_oid_fromstr(&oid, FILE_OID_BINARY_LF));
+	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("./crlf/newfile4.txt", FILE_CONTENTS_BINARY_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile4.txt"));
+	entry = git_index_get_bypath(g_index, "newfile4.txt", 0);
+	cl_git_pass(git_oid_fromstr(&oid, FILE_OID_BINARY_CRLF));
+	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("./crlf/newfile5.txt", FILE_CONTENTS_BINARY_LF_CR);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile5.txt"));
+	entry = git_index_get_bypath(g_index, "newfile5.txt", 0);
+	cl_git_pass(git_oid_fromstr(&oid, FILE_OID_BINARY_LF_CR));
+	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("./crlf/newfile6.txt", FILE_CONTENTS_BINARY_LF_CR_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile6.txt"));
+	entry = git_index_get_bypath(g_index, "newfile6.txt", 0);
+	cl_git_pass(git_oid_fromstr(&oid, FILE_OID_BINARY_LF_CR_CRLF));
+	cl_assert_equal_oid(&oid, &entry->id);
 }
 
 void test_index_crlf__safecrlf_true_autocrlf_input_text_auto_attr(void)
@@ -155,6 +446,45 @@ void test_index_crlf__safecrlf_true_autocrlf_input_text_auto_attr(void)
 
 	cl_git_mkfile("./crlf/newfile2.txt", FILE_CONTENTS_CRLF);
 	cl_git_fail(git_index_add_bypath(g_index, "newfile2.txt"));
+	CHECK_CRLF_TO_LF_ERROR
+
+	cl_git_mkfile("./crlf/newfile.txt", FILE_CONTENTS_MORE_CRLF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.txt"));
+	CHECK_CRLF_TO_LF_ERROR
+
+	cl_git_mkfile("./crlf/newfile.txt", FILE_CONTENTS_MORE_LF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.txt"));
+	CHECK_CRLF_TO_LF_ERROR
+
+	cl_git_mkfile("./crlf/newfile.txt", FILE_CONTENTS_LF_CR);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.txt"));
+
+	cl_git_mkfile("./crlf/newfile.txt", FILE_CONTENTS_LF_CR_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.txt"));
+
+	cl_git_mkfile("./crlf/newfile3.txt", FILE_CONTENTS_BINARY_LF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile3.txt"));
+	entry = git_index_get_bypath(g_index, "newfile3.txt", 0);
+	cl_git_pass(git_oid_fromstr(&oid, FILE_OID_BINARY_LF));
+	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("./crlf/newfile4.txt", FILE_CONTENTS_BINARY_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile4.txt"));
+	entry = git_index_get_bypath(g_index, "newfile4.txt", 0);
+	cl_git_pass(git_oid_fromstr(&oid, FILE_OID_BINARY_CRLF));
+	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("./crlf/newfile5.txt", FILE_CONTENTS_BINARY_LF_CR);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile5.txt"));
+	entry = git_index_get_bypath(g_index, "newfile5.txt", 0);
+	cl_git_pass(git_oid_fromstr(&oid, FILE_OID_BINARY_LF_CR));
+	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("./crlf/newfile6.txt", FILE_CONTENTS_BINARY_LF_CR_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile6.txt"));
+	entry = git_index_get_bypath(g_index, "newfile6.txt", 0);
+	cl_git_pass(git_oid_fromstr(&oid, FILE_OID_BINARY_LF_CR_CRLF));
+	cl_assert_equal_oid(&oid, &entry->id);
 }
 
 void test_index_crlf__safecrlf_true_autocrlf_input_text__no_attr(void)
@@ -173,8 +503,35 @@ void test_index_crlf__safecrlf_true_autocrlf_input_text__no_attr(void)
 	cl_git_pass(git_oid_fromstr(&oid, FILE_OID_LF));
 	cl_assert_equal_oid(&oid, &entry->id);
 
-	cl_git_mkfile("./crlf/newfile2.txt", FILE_CONTENTS_CRLF);
-	cl_git_fail(git_index_add_bypath(g_index, "newfile2.txt"));
+	cl_git_mkfile("./crlf/newfile.txt", FILE_CONTENTS_CRLF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.txt"));
+	CHECK_CRLF_TO_LF_ERROR
+
+	cl_git_mkfile("./crlf/newfile.txt", FILE_CONTENTS_MORE_CRLF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.txt"));
+	CHECK_CRLF_TO_LF_ERROR
+
+	cl_git_mkfile("./crlf/newfile.txt", FILE_CONTENTS_MORE_LF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.txt"));
+	CHECK_CRLF_TO_LF_ERROR
+
+	cl_git_mkfile("./crlf/newfile.txt", FILE_CONTENTS_LF_CR);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.txt"));
+
+	cl_git_mkfile("./crlf/newfile.txt", FILE_CONTENTS_LF_CR_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.txt"));
+
+	cl_git_mkfile("crlf/newfile.txt", FILE_CONTENTS_BINARY_LF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.txt"));
+
+	cl_git_mkfile("crlf/newfile.txt", FILE_CONTENTS_BINARY_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.txt"));
+
+	cl_git_mkfile("crlf/newfile.txt", FILE_CONTENTS_BINARY_LF_CR);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.txt"));
+
+	cl_git_mkfile("crlf/newfile.txt", FILE_CONTENTS_BINARY_LF_CR_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.txt"));
 }
 
 void test_index_crlf__safecrlf_true_no_attrs(void)
@@ -182,15 +539,840 @@ void test_index_crlf__safecrlf_true_no_attrs(void)
 	cl_repo_set_bool(g_repo, "core.autocrlf", true);
 	cl_repo_set_bool(g_repo, "core.safecrlf", true);
 
-	cl_git_mkfile("crlf/newfile.txt", ALL_LF_TEXT_RAW);
-	cl_git_fail(git_index_add_bypath(g_index, "newfile.txt")); /* vanilla git fails here (on CrLf as well as on Lf-ony platforms): "fatal: LF would be replaced by CRLF in crlf/newfile.txt" */
-
-	cl_git_mkfile("crlf/newfile.txt", ALL_CRLF_TEXT_RAW);
+	cl_git_mkfile("crlf/newfile.txt", FILE_CONTENTS_CRLF);
 	cl_git_pass(git_index_add_bypath(g_index, "newfile.txt"));
 
-	cl_git_mkfile("crlf/newfile.txt", MORE_CRLF_TEXT_RAW);
+	cl_git_mkfile("crlf/newfile.txt", FILE_CONTENTS_LF);
 	cl_git_fail(git_index_add_bypath(g_index, "newfile.txt"));
+	CHECK_LF_TO_CRLF_ERROR
 
-	cl_git_mkfile("crlf/newfile.txt", MORE_LF_TEXT_RAW);
+	cl_git_mkfile("crlf/newfile.txt", FILE_CONTENTS_MORE_CRLF);
 	cl_git_fail(git_index_add_bypath(g_index, "newfile.txt"));
+	CHECK_LF_TO_CRLF_ERROR
+
+	cl_git_mkfile("crlf/newfile.txt", FILE_CONTENTS_MORE_LF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.txt"));
+	CHECK_LF_TO_CRLF_ERROR
+
+	cl_git_mkfile("crlf/newfile.txt", FILE_CONTENTS_LF_CR);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.txt"));
+
+	cl_git_mkfile("crlf/newfile.txt", FILE_CONTENTS_LF_CR_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.txt"));
+
+	cl_git_mkfile("crlf/newfile.txt", FILE_CONTENTS_BINARY_LF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.txt"));
+
+	cl_git_mkfile("crlf/newfile.txt", FILE_CONTENTS_BINARY_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.txt"));
+
+	cl_git_mkfile("crlf/newfile.txt", FILE_CONTENTS_BINARY_LF_CR);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.txt"));
+
+	cl_git_mkfile("crlf/newfile.txt", FILE_CONTENTS_BINARY_LF_CR_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.txt"));
+}
+
+void test_index_crlf__safecrlf_true_text_eol_attrs(void)
+{
+	cl_repo_set_bool(g_repo, "core.autocrlf", false);
+	cl_repo_set_bool(g_repo, "core.safecrlf", true);
+
+	cl_git_mkfile("./crlf/.gitattributes", "*.crlf text eol=crlf\n*.lf text eol=lf\n");
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.crlf"));
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_LF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.crlf"));
+	CHECK_LF_TO_CRLF_ERROR
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_MORE_CRLF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.crlf"));
+	CHECK_LF_TO_CRLF_ERROR
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_MORE_LF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.crlf"));
+	CHECK_LF_TO_CRLF_ERROR
+	
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_LF_CR);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.crlf"));
+	CHECK_LF_TO_CRLF_ERROR
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_LF_CR_CRLF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.crlf"));
+	CHECK_LF_TO_CRLF_ERROR
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_BINARY_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.crlf"));
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_BINARY_LF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.crlf"));
+	CHECK_LF_TO_CRLF_ERROR
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_BINARY_LF_CR);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.crlf"));
+	CHECK_LF_TO_CRLF_ERROR
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_BINARY_LF_CR_CRLF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.crlf"));
+	CHECK_LF_TO_CRLF_ERROR
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_CRLF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.lf"));
+	CHECK_CRLF_TO_LF_ERROR
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_LF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.lf"));
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_MORE_CRLF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.lf"));
+	CHECK_CRLF_TO_LF_ERROR
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_MORE_LF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.lf"));
+	CHECK_CRLF_TO_LF_ERROR
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_LF_CR);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.lf"));
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_LF_CR_CRLF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.lf"));
+	CHECK_CRLF_TO_LF_ERROR
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_BINARY_CRLF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.lf"));
+	CHECK_CRLF_TO_LF_ERROR
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_BINARY_LF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.lf"));
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_BINARY_LF_CR);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.lf"));
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_BINARY_LF_CR_CRLF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.lf"));
+	CHECK_CRLF_TO_LF_ERROR
+}
+
+void test_index_crlf__safecrlf_true_autocrlf_true_crlf_attrs(void)
+{
+	cl_repo_set_bool(g_repo, "core.autocrlf", true);
+	cl_repo_set_bool(g_repo, "core.safecrlf", true);
+
+	cl_git_mkfile("./crlf/.gitattributes", "*.crlf crlf\n*.lf -crlf\n");
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.crlf"));
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_LF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.crlf"));
+	CHECK_LF_TO_CRLF_ERROR
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_MORE_CRLF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.crlf"));
+	CHECK_LF_TO_CRLF_ERROR
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_MORE_LF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.crlf"));
+	CHECK_LF_TO_CRLF_ERROR
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_LF_CR);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.crlf"));
+	CHECK_LF_TO_CRLF_ERROR
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_LF_CR_CRLF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.crlf"));
+	CHECK_LF_TO_CRLF_ERROR
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_BINARY_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.crlf"));
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_BINARY_LF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.crlf"));
+	CHECK_LF_TO_CRLF_ERROR
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_BINARY_LF_CR);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.crlf"));
+	CHECK_LF_TO_CRLF_ERROR
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_BINARY_LF_CR_CRLF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.crlf"));
+	CHECK_LF_TO_CRLF_ERROR
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.lf"));
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_LF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.lf"));
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_MORE_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.lf"));
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_MORE_LF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.lf"));
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_LF_CR);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.lf"));
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_LF_CR_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.lf"));
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_BINARY_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.lf"));
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_BINARY_LF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.lf"));
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_BINARY_LF_CR);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.lf"));
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_BINARY_LF_CR_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.lf"));
+}
+
+void test_index_crlf__safecrlf_true_autocrlf_input_crlf_attrs(void)
+{
+	cl_repo_set_string(g_repo, "core.autocrlf", "input");
+	cl_repo_set_bool(g_repo, "core.safecrlf", true);
+
+	cl_git_mkfile("./crlf/.gitattributes", "*.crlf crlf\n*.lf -crlf\n");
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_CRLF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.crlf"));
+	CHECK_CRLF_TO_LF_ERROR
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_LF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.crlf"));
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_MORE_CRLF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.crlf"));
+	CHECK_CRLF_TO_LF_ERROR
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_MORE_LF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.crlf"));
+	CHECK_CRLF_TO_LF_ERROR
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_LF_CR);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.crlf"));
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_LF_CR_CRLF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.crlf"));
+	CHECK_CRLF_TO_LF_ERROR
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_BINARY_CRLF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.crlf"));
+	CHECK_CRLF_TO_LF_ERROR
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_BINARY_LF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.crlf"));
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_BINARY_LF_CR);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.crlf"));
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_BINARY_LF_CR_CRLF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.crlf"));
+	CHECK_CRLF_TO_LF_ERROR
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.lf"));
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_LF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.lf"));
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_MORE_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.lf"));
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_MORE_LF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.lf"));
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_LF_CR);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.lf"));
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_LF_CR_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.lf"));
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_BINARY_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.lf"));
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_BINARY_LF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.lf"));
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_BINARY_LF_CR);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.lf"));
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_BINARY_LF_CR_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.lf"));
+}
+
+void test_index_crlf__safecrlf_true_autocrlf_input_eol_attrs(void)
+{
+	cl_repo_set_string(g_repo, "core.autocrlf", "input");
+	cl_repo_set_bool(g_repo, "core.safecrlf", true);
+
+	cl_git_mkfile("./crlf/.gitattributes", "*.crlf eol=crlf\n*.lf eol=lf\n");
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.crlf"));
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_LF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.crlf"));
+	CHECK_LF_TO_CRLF_ERROR
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_MORE_CRLF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.crlf"));
+	CHECK_LF_TO_CRLF_ERROR
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_MORE_LF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.crlf"));
+	CHECK_LF_TO_CRLF_ERROR
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_LF_CR);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.crlf"));
+	CHECK_LF_TO_CRLF_ERROR
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_LF_CR_CRLF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.crlf"));
+	CHECK_LF_TO_CRLF_ERROR
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_BINARY_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.crlf"));
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_BINARY_LF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.crlf"));
+	CHECK_LF_TO_CRLF_ERROR
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_BINARY_LF_CR);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.crlf"));
+	CHECK_LF_TO_CRLF_ERROR
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_BINARY_LF_CR_CRLF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.crlf"));
+	CHECK_LF_TO_CRLF_ERROR
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_CRLF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.lf"));
+	CHECK_CRLF_TO_LF_ERROR
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_LF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.lf"));
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_MORE_CRLF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.lf"));
+	CHECK_CRLF_TO_LF_ERROR
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_MORE_LF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.lf"));
+	CHECK_CRLF_TO_LF_ERROR
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_LF_CR);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.lf"));
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_LF_CR_CRLF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.lf"));
+	CHECK_CRLF_TO_LF_ERROR
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_BINARY_CRLF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.lf"));
+	CHECK_CRLF_TO_LF_ERROR
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_BINARY_LF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.lf"));
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_BINARY_LF_CR);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.lf"));
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_BINARY_LF_CR_CRLF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.lf"));
+	CHECK_CRLF_TO_LF_ERROR
+}
+
+void test_index_crlf__safecrlf_true_autocrlf_true_eol_attrs(void)
+{
+	cl_repo_set_bool(g_repo, "core.autocrlf", true);
+	cl_repo_set_bool(g_repo, "core.safecrlf", true);
+
+	cl_git_mkfile("./crlf/.gitattributes", "*.crlf eol=crlf\n*.lf eol=lf\n");
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.crlf"));
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_LF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.crlf"));
+	CHECK_LF_TO_CRLF_ERROR
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_MORE_CRLF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.crlf"));
+	CHECK_LF_TO_CRLF_ERROR
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_MORE_LF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.crlf"));
+	CHECK_LF_TO_CRLF_ERROR
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_LF_CR);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.crlf"));
+	CHECK_LF_TO_CRLF_ERROR
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_LF_CR_CRLF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.crlf"));
+	CHECK_LF_TO_CRLF_ERROR
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_BINARY_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.crlf"));
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_BINARY_LF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.crlf"));
+	CHECK_LF_TO_CRLF_ERROR
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_BINARY_LF_CR);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.crlf"));
+	CHECK_LF_TO_CRLF_ERROR
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_BINARY_LF_CR_CRLF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.crlf"));
+	CHECK_LF_TO_CRLF_ERROR
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_CRLF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.lf"));
+	CHECK_CRLF_TO_LF_ERROR
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_LF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.lf"));
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_MORE_CRLF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.lf"));
+	CHECK_CRLF_TO_LF_ERROR
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_MORE_LF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.lf"));
+	CHECK_CRLF_TO_LF_ERROR
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_LF_CR);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.lf"));
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_LF_CR_CRLF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.lf"));
+	CHECK_CRLF_TO_LF_ERROR
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_BINARY_CRLF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.lf"));
+	CHECK_CRLF_TO_LF_ERROR
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_BINARY_LF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.lf"));
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_BINARY_LF_CR);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.lf"));
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_BINARY_LF_CR_CRLF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.lf"));
+	CHECK_CRLF_TO_LF_ERROR
+}
+
+void test_index_crlf__safecrlf_true_autocrlf_false_eol_attrs(void)
+{
+	cl_repo_set_bool(g_repo, "core.autocrlf", false);
+	cl_repo_set_bool(g_repo, "core.safecrlf", true);
+
+	cl_git_mkfile("./crlf/.gitattributes", "*.crlf eol=crlf\n*.lf eol=lf\n");
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.crlf"));
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_LF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.crlf"));
+	CHECK_LF_TO_CRLF_ERROR
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_MORE_CRLF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.crlf"));
+	CHECK_LF_TO_CRLF_ERROR
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_MORE_LF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.crlf"));
+	CHECK_LF_TO_CRLF_ERROR
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_LF_CR);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.crlf"));
+	CHECK_LF_TO_CRLF_ERROR
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_LF_CR_CRLF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.crlf"));
+	CHECK_LF_TO_CRLF_ERROR
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_BINARY_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.crlf"));
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_BINARY_LF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.crlf"));
+	CHECK_LF_TO_CRLF_ERROR
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_BINARY_LF_CR);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.crlf"));
+	CHECK_LF_TO_CRLF_ERROR
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_BINARY_LF_CR_CRLF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.crlf"));
+	CHECK_LF_TO_CRLF_ERROR
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_CRLF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.lf"));
+	CHECK_CRLF_TO_LF_ERROR
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_LF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.lf"));
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_MORE_CRLF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.lf"));
+	CHECK_CRLF_TO_LF_ERROR
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_MORE_LF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.lf"));
+	CHECK_CRLF_TO_LF_ERROR
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_LF_CR);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.lf"));
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_LF_CR_CRLF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.lf"));
+	CHECK_CRLF_TO_LF_ERROR
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_BINARY_CRLF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.lf"));
+	CHECK_CRLF_TO_LF_ERROR
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_BINARY_LF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.lf"));
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_BINARY_LF_CR);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.lf"));
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_BINARY_LF_CR_CRLF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.lf"));
+	CHECK_CRLF_TO_LF_ERROR
+}
+
+void test_index_crlf__safecrlf_true_autocrlf_true_text_eol_attrs(void)
+{
+	cl_repo_set_bool(g_repo, "core.autocrlf", true);
+	cl_repo_set_bool(g_repo, "core.safecrlf", true);
+
+	cl_git_mkfile("./crlf/.gitattributes", "*.crlf text eol=crlf\n*.lf text eol=lf\n");
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.crlf"));
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_LF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.crlf"));
+	CHECK_LF_TO_CRLF_ERROR
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_MORE_CRLF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.crlf"));
+	CHECK_LF_TO_CRLF_ERROR
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_MORE_LF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.crlf"));
+	CHECK_LF_TO_CRLF_ERROR
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_LF_CR);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.crlf"));
+	CHECK_LF_TO_CRLF_ERROR
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_LF_CR_CRLF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.crlf"));
+	CHECK_LF_TO_CRLF_ERROR
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_BINARY_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.crlf"));
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_BINARY_LF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.crlf"));
+	CHECK_LF_TO_CRLF_ERROR
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_BINARY_LF_CR);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.crlf"));
+	CHECK_LF_TO_CRLF_ERROR
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_BINARY_LF_CR_CRLF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.crlf"));
+	CHECK_LF_TO_CRLF_ERROR
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_CRLF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.lf"));
+	CHECK_CRLF_TO_LF_ERROR
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_LF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.lf"));
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_MORE_CRLF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.lf"));
+	CHECK_CRLF_TO_LF_ERROR
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_MORE_LF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.lf"));
+	CHECK_CRLF_TO_LF_ERROR
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_LF_CR);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.lf"));
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_LF_CR_CRLF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.lf"));
+	CHECK_CRLF_TO_LF_ERROR
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_BINARY_CRLF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.lf"));
+	CHECK_CRLF_TO_LF_ERROR
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_BINARY_LF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.lf"));
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_BINARY_LF_CR);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.lf"));
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_BINARY_LF_CR_CRLF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.lf"));
+	CHECK_CRLF_TO_LF_ERROR
+}
+
+void test_index_crlf__safecrlf_true_autocrlf_false_text_eol_attrs(void)
+{
+	cl_repo_set_bool(g_repo, "core.autocrlf", false);
+	cl_repo_set_bool(g_repo, "core.safecrlf", true);
+
+	cl_git_mkfile("./crlf/.gitattributes", "*.crlf text eol=crlf\n*.lf text eol=lf\n");
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.crlf"));
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_LF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.crlf"));
+	CHECK_LF_TO_CRLF_ERROR
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_MORE_CRLF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.crlf"));
+	CHECK_LF_TO_CRLF_ERROR
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_MORE_LF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.crlf"));
+	CHECK_LF_TO_CRLF_ERROR
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_LF_CR);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.crlf"));
+	CHECK_LF_TO_CRLF_ERROR
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_LF_CR_CRLF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.crlf"));
+	CHECK_LF_TO_CRLF_ERROR
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_BINARY_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.crlf"));
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_BINARY_LF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.crlf"));
+	CHECK_LF_TO_CRLF_ERROR
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_BINARY_LF_CR);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.crlf"));
+	CHECK_LF_TO_CRLF_ERROR
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_BINARY_LF_CR_CRLF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.crlf"));
+	CHECK_LF_TO_CRLF_ERROR
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_CRLF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.lf"));
+	CHECK_CRLF_TO_LF_ERROR
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_LF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.lf"));
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_MORE_CRLF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.lf"));
+	CHECK_CRLF_TO_LF_ERROR
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_MORE_LF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.lf"));
+	CHECK_CRLF_TO_LF_ERROR
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_LF_CR);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.lf"));
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_LF_CR_CRLF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.lf"));
+	CHECK_CRLF_TO_LF_ERROR
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_BINARY_CRLF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.lf"));
+	CHECK_CRLF_TO_LF_ERROR
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_BINARY_LF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.lf"));
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_BINARY_LF_CR);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.lf"));
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_BINARY_LF_CR_CRLF);
+	cl_git_fail(git_index_add_bypath(g_index, "newfile.lf"));
+	CHECK_CRLF_TO_LF_ERROR
+}
+
+void test_index_crlf__attrs(void)
+{
+	const git_index_entry *entry;
+	git_oid oid;
+
+	cl_git_pass(git_oid_fromstr(&oid, FILE_OID_LF_CR));
+
+	cl_repo_set_bool(g_repo, "core.autocrlf", false);
+	cl_repo_set_bool(g_repo, "core.safecrlf", false);
+
+	cl_git_mkfile("./crlf/.gitattributes", "*.crlf text eol=crlf\n*.lf text eol=lf\n");
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_LF_CR);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.crlf"));
+	entry = git_index_get_bypath(g_index, "newfile.crlf", 0);
+	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_LF_CR);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.lf"));
+	entry = git_index_get_bypath(g_index, "newfile.lf", 0);
+	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("crlf/newfile2.crlf", FILE_CONTENTS_LF_CR_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile2.crlf"));
+	entry = git_index_get_bypath(g_index, "newfile2.crlf", 0);
+	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("crlf/newfile2.lf", FILE_CONTENTS_LF_CR_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile2.lf"));
+	entry = git_index_get_bypath(g_index, "newfile2.lf", 0);
+	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("./crlf/newfile.crlf", FILE_CONTENTS_MORE_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.crlf"));
+	entry = git_index_get_bypath(g_index, "newfile.crlf", 0);
+	cl_git_pass(git_oid_fromstr(&oid, "37bb7fa3debea1cbb65576733a457347ea1bb74d"));
+	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("./crlf/newfile.crlf", FILE_CONTENTS_MORE_LF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.crlf"));
+	entry = git_index_get_bypath(g_index, "newfile.crlf", 0);
+	cl_git_pass(git_oid_fromstr(&oid, "2cda6f203b2f56d5c416b94b28670ec3eafb1398"));
+	cl_assert_equal_oid(&oid, &entry->id);
+	
+	cl_git_mkfile("./crlf/newfile.lf", FILE_CONTENTS_MORE_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.lf"));
+	entry = git_index_get_bypath(g_index, "newfile.lf", 0);
+	cl_git_pass(git_oid_fromstr(&oid, "37bb7fa3debea1cbb65576733a457347ea1bb74d"));
+	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("./crlf/newfile.lf", FILE_CONTENTS_MORE_LF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.lf"));
+	entry = git_index_get_bypath(g_index, "newfile.lf", 0);
+	cl_git_pass(git_oid_fromstr(&oid, "2cda6f203b2f56d5c416b94b28670ec3eafb1398"));
+	cl_assert_equal_oid(&oid, &entry->id);
+}
+
+void test_index_crlf__crlf_attrs(void)
+{
+	const git_index_entry *entry;
+	git_oid oid;
+
+	cl_repo_set_bool(g_repo, "core.autocrlf", false);
+	cl_repo_set_bool(g_repo, "core.safecrlf", false);
+
+	cl_git_mkfile("./crlf/.gitattributes", "*.crlf crlf\n*.lf -crlf\n");
+
+	cl_git_mkfile("./crlf/newfile.crlf", FILE_CONTENTS_MORE_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.crlf"));
+	entry = git_index_get_bypath(g_index, "newfile.crlf", 0);
+	cl_git_pass(git_oid_fromstr(&oid, "37bb7fa3debea1cbb65576733a457347ea1bb74d"));
+	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("./crlf/newfile.crlf", FILE_CONTENTS_MORE_LF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.crlf"));
+	entry = git_index_get_bypath(g_index, "newfile.crlf", 0);
+	cl_git_pass(git_oid_fromstr(&oid, "2cda6f203b2f56d5c416b94b28670ec3eafb1398"));
+	cl_assert_equal_oid(&oid, &entry->id);
+	
+	cl_git_mkfile("./crlf/newfile.lf", FILE_CONTENTS_MORE_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.lf"));
+	entry = git_index_get_bypath(g_index, "newfile.lf", 0);
+	cl_git_pass(git_oid_fromstr(&oid, "0ff5a53f19bfd2b5eea1ba550295c47515678987"));
+	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("./crlf/newfile.lf", FILE_CONTENTS_MORE_LF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.lf"));
+	entry = git_index_get_bypath(g_index, "newfile.lf", 0);
+	cl_git_pass(git_oid_fromstr(&oid, "04de00b358f13389948756732158eaaaefa1448c"));
+	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("crlf/newfile.crlf", FILE_CONTENTS_LF_CR);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.crlf"));
+	entry = git_index_get_bypath(g_index, "newfile.crlf", 0);
+	cl_git_pass(git_oid_fromstr(&oid, FILE_OID_LF_CR));
+	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("crlf/newfile.lf", FILE_CONTENTS_LF_CR);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile.lf"));
+	entry = git_index_get_bypath(g_index, "newfile.lf", 0);
+	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("crlf/newfile2.crlf", FILE_CONTENTS_LF_CR_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile2.crlf"));
+	entry = git_index_get_bypath(g_index, "newfile2.crlf", 0);
+	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("crlf/newfile2.lf", FILE_CONTENTS_LF_CR_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile2.lf"));
+	entry = git_index_get_bypath(g_index, "newfile2.lf", 0);
+	cl_git_pass(git_oid_fromstr(&oid, FILE_OID_LF_CR_CRLF));
+	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("./crlf/newfile3.crlf", FILE_CONTENTS_BINARY_LF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile3.crlf"));
+	entry = git_index_get_bypath(g_index, "newfile3.crlf", 0);
+	cl_git_pass(git_oid_fromstr(&oid, FILE_OID_BINARY_LF));
+	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("./crlf/newfile4.crlf", FILE_CONTENTS_BINARY_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile4.crlf"));
+	entry = git_index_get_bypath(g_index, "newfile4.crlf", 0);
+	cl_git_pass(git_oid_fromstr(&oid, FILE_OID_BINARY_LF));
+	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("./crlf/newfile5.crlf", FILE_CONTENTS_BINARY_LF_CR);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile5.crlf"));
+	entry = git_index_get_bypath(g_index, "newfile5.crlf", 0);
+	cl_git_pass(git_oid_fromstr(&oid, FILE_OID_BINARY_LF_CR));
+	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("./crlf/newfile6.crlf", FILE_CONTENTS_BINARY_LF_CR_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile6.crlf"));
+	entry = git_index_get_bypath(g_index, "newfile6.crlf", 0);
+	cl_git_pass(git_oid_fromstr(&oid, FILE_OID_BINARY_LF_CR));
+	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("./crlf/newfile3.lf", FILE_CONTENTS_BINARY_LF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile3.lf"));
+	entry = git_index_get_bypath(g_index, "newfile3.lf", 0);
+	cl_git_pass(git_oid_fromstr(&oid, FILE_OID_BINARY_LF));
+	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("./crlf/newfile4.lf", FILE_CONTENTS_BINARY_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile4.lf"));
+	entry = git_index_get_bypath(g_index, "newfile4.lf", 0);
+	cl_git_pass(git_oid_fromstr(&oid, FILE_OID_BINARY_CRLF));
+	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("./crlf/newfile5.lf", FILE_CONTENTS_BINARY_LF_CR);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile5.lf"));
+	entry = git_index_get_bypath(g_index, "newfile5.lf", 0);
+	cl_git_pass(git_oid_fromstr(&oid, FILE_OID_BINARY_LF_CR));
+	cl_assert_equal_oid(&oid, &entry->id);
+
+	cl_git_mkfile("./crlf/newfile6.lf", FILE_CONTENTS_BINARY_LF_CR_CRLF);
+	cl_git_pass(git_index_add_bypath(g_index, "newfile6.lf"));
+	entry = git_index_get_bypath(g_index, "newfile6.lf", 0);
+	cl_git_pass(git_oid_fromstr(&oid, FILE_OID_BINARY_LF_CR_CRLF));
+	cl_assert_equal_oid(&oid, &entry->id);
 }
-- 
1.8.1.2

